#!/usr/bin/env ruby

require 'commander/import'
require 'jira'
require 'mongo/jira'
require 'mongo/jira/jabber'
require 'mongo/jira/commands'
require 'json'
require 'ruby-progressbar'

$config = "#{ENV['HOME']}/.mongo-jira.json"

tengen = HighLine::ColorScheme.new do |cs|
  cs[:released] = [:bold, :green]
  cs[:rc] = [:bold, :cyan]
  cs[:error] = [:bold, :red]
  cs[:password] = [:red]
  cs[:developers] = [:bold, :reverse, :green]
  cs[:customers] = [:bold, :reverse, :red]
  cs[:everybody] = [:bold]

  cs[:tengen] = [:bold, :green]
  cs[:customer] = []
  cs[:downloaded] = [:green]
  cs[:blockerp1] = [:bold, :red]
  cs[:criticalp2] = [:red]
  cs[:majorp3] = [:cyan]
  cs[:minorp4] = [:green]
  cs[:trivialp5] = [:green]

  cs[:unresolved] = [:bold, :red]
  cs[:unknown] = [:bold, :red]
  cs[:fixed] = [:bold, :green]
  cs[:inprogress] = [:bold, :green]
  cs[:waitingforcustomer] = [:bold, :reverse, :red]
  cs[:open] = [:reverse, :red]
  cs[:closed] = [:bold, :reverse, :green]
  cs[:resolved] = [:bold, :reverse, :green]
  cs[:duplicate] = [:bold, :reverse, :green]
  cs[:incomplete] = [:bold, :reverse, :green]
  cs[:goneaway] = [:bold, :reverse, :green]
  cs[:waitingforbugfix] = [:bold, :reverse, :green]
  cs[:worksasdesigned] = [:bold, :reverse, :green]
  cs[:wontfix] = [:bold, :reverse, :green]
  cs[:cannotreproduce] = [:bold, :reverse, :green]
  cs[:incodereview] = [:bold, :reverse, :green]
  cs[:waitingforuserinput] = [:bold, :reverse, :green]

end
HighLine.color_scheme = tengen

program :version, Mongo::Jira::VERSION
program :description, 'Set of JIRA command line tools'
program(:help, 'Common Errors',<<END)
error: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed.
    Try :

        rvm osx-ssl-certs update all

    If you get an error with the following :

      `require': cannot load such file -- mkmf (LoadError)

    Then try :

      sudo apt-get install ruby-dev

END

program(:help, 'Reporting Errors',<<END)
add --trace to the end of the command , re-run and email me the log.

END

program(:help, 'Supported Versions',<<END)
I've tested the gem with the following ruby versions:

       ruby-1.9.2
       ruby-1.9.3
       ruby-2.0.0

    It does not work on 1.8.7 :

	     activesupport requires Ruby version >= 1.9.3.

END

$level=0
$jabberrc=nil
$jabber=nil
$limit=nil
$growl=[]
$view='terminal'

global_option('-c', '--creds FILE', 'Load config data for your commands to use') { |file| $config = file }
global_option('-V', 'increment verbosity level, i.e. -VV for higher debug level') { $level += 1}

global_option('--jabber DETAILS', 'the jabber details {from:"from", to:["the-to]",password:"wwwwXXXXyyyyZZZZ"}') {|jabber|$jabber=jabber}
global_option('--jabberrc FILE', 'the jabberrc file') {|jabberrc |$jabberrc=jabberrc}
global_option('--limit [limit]', 'limit the results set ') {|limit|$limit=limit}

global_option('--growl', 'growl the results set to localhost') {$growl<<%w(localhost)}
global_option('--growl-to=a,b,c',Array, 'growl the results set ') {|hosts| $growl<<[hosts]}

global_option('--view view', 'render with terminal,plain,short') {|view| $view=view}
global_option('--as type', 'render as view can be header, ticket,id') {|as| $as=as}

default_command :show

commands = Mongo::Jira::Commands.new

command :init do |c|
  c.syntax = 'jira init [options]'
  c.summary = 'Run this command to initialize jira mongo gem'
  c.description = 'This command will walk you through the account details that are needed.'
  c.example 'description', 'jira init'
  c.action do
    commands.init($config)
  end
end

command :download do |c|
  c.syntax = 'jira download <ticket>* [options]'
  c.summary = 'download files attached to this ticket'
  c.description=<<END
Download all the files attached attached to a ticket.

If no parameters are supplied then all new attachments will be downloaded. By default the file
structure is flattened and the files are downloaded to the 'attachment' directory.

If the '--force' flag is used then all or files matching a glob are downloaded (regardless of whether they
are currently downloaded). By default the force pattern is a glob and '*' are prepended and appended to the glob.
So the following 2 commands are equivalent :

  $> jira download pr-1111
  $> jira download pr-1111 pr-2222
  $> jira download pr-1111 --force filename
  $> jira download pr-1111 --force '*filename*'
  $> jira download pr-1111 --force '*filename*' --to attachment

Multiple patterns can also be supplied:

  $> jira download pr-1111 --force filename1,file2
END
  c.example 'download all the new files from pr-1111', 'jira download pr-1111'
  c.option '--dryrun', 'don\'t do the download just print what would happen '
  c.option '-f','--[no-]flatten', 'flatten directory'
  c.option '--silent', 'don\'t display progress'
  c.option '--force [GLOBS]', String, 'force download of matching files'
  c.option '--to LOCATION', String, 'download to LOCATION, defaults to ticket name'
  c.action do |args,options|
    options.default(:dryrun => false, :silent => false, :flatten=>true, :to=>nil)
    if options.force.nil? || options.force.is_a?(TrueClass)
      force = (options.force.nil? ? %w() : %w(*))
    else
      force = options.force.split(/[,\s]/).collect{|g| "*#{g.chomp}*"}
    end

    tids = args|| %w(.*)
    tids.each do |tid|
      commands.download(tid,options.__hash__.merge({limit:$limit, as:$as, force:force}))
    end
  end
end

command :projects do |c|
  c.syntax = 'jira projects <glob> [options]'
  c.summary = 'list all the projects'
  c.description = ''
  c.example 'description', 'command example'
  c.action do |args,options|
    if args.length == 0
      globs= %w(*)
    else
      globs = args.collect{|g| "*#{g.chomp}*"}
    end
    commands.projects(globs,options.__hash__.merge({limit:$limit,as:$as}))
  end
end

alias_command :test, :projects

command :show do |c|
  c.syntax = 'jira ticket <id>* [options]'
  c.summary = 'view a ticket or list of tickets'
  c.description= <<END

  $> jira show pr-1111
  $> jira ticket pr-1111
  $> jira show pr-1111 pr-2222
  $> jira show pr-1111 --reverse | less -R
END
  c.option '--reverse', 'print the comments in reverse order'
  c.action do |args, options|
    if args.length == 0
      command(:help).run()
      next
    end

    tickets = commands.show(args,options.__hash__.merge({limit:$limit, as:($as)||'terminal/ticket'}))

    jabber(commands,tickets, options)
    growler(commands,tickets, options)
  end
end
alias_command :ticket, :show

command :open do |c|
  c.syntax = 'jira open <ids>* [options]'
  c.summary = 'open a ticket'
  c.description = 'open a ticket in the browser'
  c.example 'description', 'jira open pr-1111'
  c.option '--some-switch', 'Some switch that does something'
  c.action do |args, options|
    tids = (args || %w(.*))

    tickets = commands.open(tids,options.__hash__.merge({limit:$limit, as:$as}))

    jabber(commands,tickets, options)
    growler(commands,tickets, options)
  end
end

command :query do |c|
  c.syntax = 'jira query <jql> [options]'
  c.summary = 'run a jql query '
  c.description =<<END
Use JQL syntax to find tickets.

Sample queries :
    $> jira query 'project = CS AND labels = fs AND (Assignee is NULL) AND status = Open ORDER BY priority DESC' -> commercial support, no owner
    $> jira query 'project = CS AND (Assignee is NULL) AND status = Open ORDER BY priority DESC' -> commercial support, no owner
    $> jira query 'project in (CS, MMSSUPPORT) AND (Assignee is NULL) AND status = Open ORDER BY priority DESC' -> commercial support, no owner
    $> jira query 'label = "fs"' -> find issues resolved by ME
    $> jira query 'status WAS "Resolved" BY currentUser()' -> find issues resolved by ME
    $> jira query 'assignee = currentUser() OR owner = currentUser() ' -> find issues resolved by ME
    $> jira query 'owner = currentUser() AND status in  (open , "waiting for customer") '
    $> jira query 'assignee is EMPTY AND status in  ("waiting for customer") ORDER BY updated DESC '
END
  c.example 'description', 'command example'
  c.action do |args, options|
    tickets = commands.query(args,options.__hash__.merge({limit:$limit, as:$as}))

    jabber(commands,tickets, options)
    growler(commands,tickets, options)
  end
end

command :find do |c|
  c.syntax = 'jira find <key words>'
  c.summary = 'find ticket with keywords matching the following fields "summary description comment"'
  c.description =<<END
Find tickets by keywords

Sample find:
    $> jira find Test aggregation framework      # match any of the words
    $> jira find 'Test aggregation framework'    # match any of the words
    $> jira find '"Test aggregation framework"'  # match exact phrase
END
  c.action do |args,options|
    tickets = commands.find(args,options.__hash__.merge({limit:$limit, as:$as}))

    jabber(commands,tickets, options)
    growler(commands,tickets, options)

  end
end

command :fixversions do |c|
  c.syntax = 'jira fixversions [versions]*'
  c.summary = 'find ticket fixed by version'
  c.option '--from project1,project2', 'print plain results'
  c.option '--to project1,project2', 'print plain results'

  c.description =<<END
Find tickets by keywords

Sample find:
    $> jira fixversions 2.4.6 2.4.5
END
  c.action do |args,options|
    options.default(:from=>%w(SERVER), :to=>%w(CS))

    tickets = commands.fixversions(args,options.__hash__.merge({limit:$limit, as:$as}))

    jabber(commands,tickets, options)
    growler(commands,tickets, options)
  end
end

def jabber(commands,tickets,options)
  return if tickets.empty?

  jconf = nil
  jconf = JSON.parse($jabber) if $jabber
  jconf = JSON.parse(IO.read($jabberrc)) if !jconf && $jabberrc

  jconf.symbolize_keys!() if jconf

  j = nil
  j = Mongo::Jira::Jabber.new(jconf) if jconf && jconf[:to]

  if j
    message = tickets.collect{|ticket|
      commands.render(Mongo::Jira::Model::Ticket.new(ticket),{:reverse=>options.reverse, :as =>(options[:as] ||'jabber/ticket')})
    }
    j.talk(jconf[:to], 'new tickets' , message.join("\n"))
  end
end

def growler(commands,tickets,options)
  return if tickets.empty?

  $growl.flatten!
  $growl.uniq!
  if $growl.length > 0
    tickets.each{|ticket|
      message = commands.render(Mongo::Jira::Model::Ticket.new(ticket),{:reverse=>options.reverse, :as =>(options[:as] ||'growler/ticket')})
      $growl.each{|host|notify_info(message , :host=>host)}
    }
  end
end


TRACE=4
DEBUG=3
LOG=2
INFO=1

# -VVVV
def trace(*args)
  puts args.join if $level >= TRACE
end

# -VVV
def debug(*args)
  puts (args||['no args']).join if $level >= DEBUG
end

# -VV
def log(*args)
  puts (args||['no args']).join if $level >=LOG
end

# -V
def info(*args)
  puts (args||['no args']).join if $level >= INFO
end

# @param [Object] default
def prompt(name, default=nil)
  ask("#{name} (<%= color(\"#{default}\", RED) %>) ? ", lambda { |v| v.blank? ? default : v })
end

